/******************************************************************************
 * This file was generated by langium-cli 0.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, Reference, isAstNode } from 'langium';

export interface Annotator extends AstNode {
    readonly $container: Annotators;
    desc: string
    name: string
    req: string
    type: AnnotationType
    who: string
}

export const Annotator = 'Annotator';

export function isAnnotator(item: unknown): item is Annotator {
    return reflection.isInstance(item, Annotator);
}

export interface Annotators extends AstNode {
    readonly $container: DataProvenance;
    annotations: Array<Annotator>
    name: 'Data Preprocessing:'
    preprocess: Array<PreProcess>
}

export const Annotators = 'Annotators';

export function isAnnotators(item: unknown): item is Annotators {
    return reflection.isInstance(item, Annotators);
}

export interface Area extends AstNode {
    readonly $container: GeneralInfo;
    area: Array<string>
    name: 'Area:'
}

export const Area = 'Area';

export function isArea(item: unknown): item is Area {
    return reflection.isInstance(item, Area);
}

export interface Attribute extends AstNode {
    readonly $container: Instance;
    attdesc: string
    attType: Categor | Numeri
    completnessAtt: number
    name: string
    unique: number
}

export const Attribute = 'Attribute';

export function isAttribute(item: unknown): item is Attribute {
    return reflection.isInstance(item, Attribute);
}

export interface Author extends AstNode {
    readonly $container: Authors;
    email: string
    name: string
}

export const Author = 'Author';

export function isAuthor(item: unknown): item is Author {
    return reflection.isInstance(item, Author);
}

export interface Authoring extends AstNode {
    readonly $container: GeneralInfo;
    authors: Array<Authors>
    founding: Array<Founders>
    licence: string
    maintenance: Array<Maintenance>
    name: 'Authoring:'
}

export const Authoring = 'Authoring';

export function isAuthoring(item: unknown): item is Authoring {
    return reflection.isInstance(item, Authoring);
}

export interface Authors extends AstNode {
    readonly $container: Authoring;
    authors: Array<Author>
    name: 'Authors:'
}

export const Authors = 'Authors';

export function isAuthors(item: unknown): item is Authors {
    return reflection.isInstance(item, Authors);
}

export interface Binary extends AstNode {
    readonly $container: Categor;
    attspar: number
    sym: Symetric
}

export const Binary = 'Binary';

export function isBinary(item: unknown): item is Binary {
    return reflection.isInstance(item, Binary);
}

export interface Categor extends AstNode {
    readonly $container: Attribute;
    binary: Binary
    catdist: string
    mode: string
    name: 'Categorical'
}

export const Categor = 'Categor';

export function isCategor(item: unknown): item is Categor {
    return reflection.isInstance(item, Categor);
}

export interface Composition extends AstNode {
    readonly $container: Declaration;
    compodesc: Array<string>
    dependencies: Dependencies
    instances: Array<Instances>
    name: 'Composition:'
    numberInst: number
    relation: RelationInstances
    sample: string
    splits: string
}

export const Composition = 'Composition';

export function isComposition(item: unknown): item is Composition {
    return reflection.isInstance(item, Composition);
}

export interface DataProvenance extends AstNode {
    readonly $container: Declaration;
    annotations: Array<Annotators>
    curation: string
    datasources: Array<DataSources>
    name: 'Data Provenance:'
}

export const DataProvenance = 'DataProvenance';

export function isDataProvenance(item: unknown): item is DataProvenance {
    return reflection.isInstance(item, DataProvenance);
}

export interface DataQuality extends AstNode {
    readonly $container: Instance;
    balance: string
    complet: number
    name: 'Data Quality:'
    noisy: string
    sparsity: number
}

export const DataQuality = 'DataQuality';

export function isDataQuality(item: unknown): item is DataQuality {
    return reflection.isInstance(item, DataQuality);
}

export interface DataSource extends AstNode {
    readonly $container: DataSources;
    desc: string
    how: string
    mapInstance?: Reference<Instance>
    name: string
    noise: string
    priv: string
    req: string
    when: string
    who: string
}

export const DataSource = 'DataSource';

export function isDataSource(item: unknown): item is DataSource {
    return reflection.isInstance(item, DataSource);
}

export interface DataSources extends AstNode {
    readonly $container: DataProvenance;
    datasources: Array<DataSource>
    name: 'Data Sources:'
}

export const DataSources = 'DataSources';

export function isDataSources(item: unknown): item is DataSources {
    return reflection.isInstance(item, DataSources);
}

export interface Declaration extends AstNode {
    readonly $container: DescriptionDataset;
    composition: Composition
    generalinfo: GeneralInfo
    name: string
    provenance: DataProvenance
    socialConcerns: SocialConcerns
}

export const Declaration = 'Declaration';

export function isDeclaration(item: unknown): item is Declaration {
    return reflection.isInstance(item, Declaration);
}

export interface Dependencies extends AstNode {
    readonly $container: Composition;
    archival: string
    desc: string
    limit: string
    restriction: string
}

export const Dependencies = 'Dependencies';

export function isDependencies(item: unknown): item is Dependencies {
    return reflection.isInstance(item, Dependencies);
}

export interface DescriptionDataset extends AstNode {
    elements: Array<Declaration>
}

export const DescriptionDataset = 'DescriptionDataset';

export function isDescriptionDataset(item: unknown): item is DescriptionDataset {
    return reflection.isInstance(item, DescriptionDataset);
}

export interface Distribution extends AstNode {
    readonly $container: GeneralInfo;
    name: 'Distribution:'
    past: string
    public: string
}

export const Distribution = 'Distribution';

export function isDistribution(item: unknown): item is Distribution {
    return reflection.isInstance(item, Distribution);
}

export interface Founder extends AstNode {
    readonly $container: Founders;
    grantor: string
    name: string
    type: FoundersType
}

export const Founder = 'Founder';

export function isFounder(item: unknown): item is Founder {
    return reflection.isInstance(item, Founder);
}

export interface Founders extends AstNode {
    readonly $container: Authoring;
    founders: Array<Founder>
    name: 'Founders:'
}

export const Founders = 'Founders';

export function isFounders(item: unknown): item is Founders {
    return reflection.isInstance(item, Founders);
}

export interface GeneralInfo extends AstNode {
    readonly $container: Declaration;
    area: Area
    authoring: Authoring
    citation: string
    description: string
    descriptionGaps: string
    descriptionpurpose: string
    descriptionTasks: string
    distribution: Distribution
    ident: string
    name: 'Metadata:'
    tags: Tags
    title: string
    uses: Uses
    version: string
}

export const GeneralInfo = 'GeneralInfo';

export function isGeneralInfo(item: unknown): item is GeneralInfo {
    return reflection.isInstance(item, GeneralInfo);
}

export interface Instance extends AstNode {
    readonly $container: Instances;
    attributes: Array<Attribute>
    dataQuality: Array<DataQuality>
    descript: string
    labels?: Reference<Labels>
    name: string
    numIns: number
    records: number
    rules: Array<IntegrityRules>
    statistics: Array<InstanceStatistics>
    type: InsType
}

export const Instance = 'Instance';

export function isInstance(item: unknown): item is Instance {
    return reflection.isInstance(item, Instance);
}

export interface Instances extends AstNode {
    readonly $container: Composition;
    instances: Array<Instance>
    name: 'Instances:'
}

export const Instances = 'Instances';

export function isInstances(item: unknown): item is Instances {
    return reflection.isInstance(item, Instances);
}

export interface InstanceStatistics extends AstNode {
    readonly $container: Instance;
    name: 'Instance Statistics:'
    plot: Array<string>
}

export const InstanceStatistics = 'InstanceStatistics';

export function isInstanceStatistics(item: unknown): item is InstanceStatistics {
    return reflection.isInstance(item, InstanceStatistics);
}

export interface IntegrityRules extends AstNode {
    readonly $container: Instance;
    desc: string
}

export const IntegrityRules = 'IntegrityRules';

export function isIntegrityRules(item: unknown): item is IntegrityRules {
    return reflection.isInstance(item, IntegrityRules);
}

export interface Labels extends AstNode {
    desc: string
    map?: Reference<Attribute>
    name: string
}

export const Labels = 'Labels';

export function isLabels(item: unknown): item is Labels {
    return reflection.isInstance(item, Labels);
}

export interface Maintainer extends AstNode {
    readonly $container: Maintenance;
    email: string
    name: string
}

export const Maintainer = 'Maintainer';

export function isMaintainer(item: unknown): item is Maintainer {
    return reflection.isInstance(item, Maintainer);
}

export interface Maintenance extends AstNode {
    readonly $container: Authoring;
    contribGuides: string
    dataRetention: string
    erratum: string
    maintainers: Array<Maintainer>
    name: 'Maintenance:'
    support: string
}

export const Maintenance = 'Maintenance';

export function isMaintenance(item: unknown): item is Maintenance {
    return reflection.isInstance(item, Maintenance);
}

export interface Numeri extends AstNode {
    readonly $container: Attribute;
    iqr: number
    max: number
    mean: number
    median: number
    min: number
    name: 'Numerical'
    quartiles: string
    std: number
}

export const Numeri = 'Numeri';

export function isNumeri(item: unknown): item is Numeri {
    return reflection.isInstance(item, Numeri);
}

export interface PreProcess extends AstNode {
    readonly $container: Annotators;
    desc: string
    name: string
}

export const PreProcess = 'PreProcess';

export function isPreProcess(item: unknown): item is PreProcess {
    return reflection.isInstance(item, PreProcess);
}

export interface Privacy extends AstNode {
    readonly $container: SocialConcerns;
    legal: string
    priva?: Reference<Attribute>
}

export const Privacy = 'Privacy';

export function isPrivacy(item: unknown): item is Privacy {
    return reflection.isInstance(item, Privacy);
}

export interface Relation extends AstNode {
    readonly $container: RelationInstances;
    attRel?: Reference<Attribute>
    attRelTarget?: Reference<Attribute>
    insRel?: Reference<Instance>
    name: string
}

export const Relation = 'Relation';

export function isRelation(item: unknown): item is Relation {
    return reflection.isInstance(item, Relation);
}

export interface RelationInstances extends AstNode {
    readonly $container: Composition;
    relation: Array<Relation>
}

export const RelationInstances = 'RelationInstances';

export function isRelationInstances(item: unknown): item is RelationInstances {
    return reflection.isInstance(item, RelationInstances);
}

export interface SensitiveData extends AstNode {
    readonly $container: SocialConcerns;
    desc: string
    offDiscussion: string
    procGroups: string
    senseAtt?: Reference<Attribute>
}

export const SensitiveData = 'SensitiveData';

export function isSensitiveData(item: unknown): item is SensitiveData {
    return reflection.isInstance(item, SensitiveData);
}

export interface SocialConcerns extends AstNode {
    readonly $container: Declaration;
    bias: string
    impact: string
    name: 'Social Concerns:'
    privacy: Array<Privacy>
    sensitive: SensitiveData
}

export const SocialConcerns = 'SocialConcerns';

export function isSocialConcerns(item: unknown): item is SocialConcerns {
    return reflection.isInstance(item, SocialConcerns);
}

export interface Tags extends AstNode {
    readonly $container: GeneralInfo;
    name: 'Tags:'
    tags: Array<string>
}

export const Tags = 'Tags';

export function isTags(item: unknown): item is Tags {
    return reflection.isInstance(item, Tags);
}

export interface Uses extends AstNode {
    readonly $container: GeneralInfo;
    future: string
    name: 'Uses:'
    past: string
    recommend: string
    repo: string
}

export const Uses = 'Uses';

export function isUses(item: unknown): item is Uses {
    return reflection.isInstance(item, Uses);
}

export type QualifiedName = string

export type DataTypes = 'String' | 'Integer' | 'Boolean' | 'Other'

export type ATtype = string

export type InsType = 'Record_Data' | 'Time-Series' | 'Ordenred' | 'Graph' | 'Other'

export type FoundersType = 'private' | 'public' | 'mixed'

export type Operation = '<' | '>' | '=' | '!=' | '+' | '-'

export type Categoric = string

export type Numeric = string

export type Symetric = 'Symmetric' | 'Asymmetric'

export type Proven = string

export type Social = string

export type AnnotationType = 'Bounding boxes' | 'Lines and splines' | 'Semantinc Segmentation' | '3D cuboids' | 'Polygonal segmentation' | 'Landmark and key-point' | 'Image and video annotations' | 'Entity annotation' | 'Content and text categorization'

export type datasetDescriptorAstType = 'Annotator' | 'Annotators' | 'Area' | 'Attribute' | 'Author' | 'Authoring' | 'Authors' | 'Binary' | 'Categor' | 'Composition' | 'DataProvenance' | 'DataQuality' | 'DataSource' | 'DataSources' | 'Declaration' | 'Dependencies' | 'DescriptionDataset' | 'Distribution' | 'Founder' | 'Founders' | 'GeneralInfo' | 'Instance' | 'Instances' | 'InstanceStatistics' | 'IntegrityRules' | 'Labels' | 'Maintainer' | 'Maintenance' | 'Numeri' | 'PreProcess' | 'Privacy' | 'Relation' | 'RelationInstances' | 'SensitiveData' | 'SocialConcerns' | 'Tags' | 'Uses';

export type datasetDescriptorAstReference = 'DataSource:mapInstance' | 'Instance:labels' | 'Labels:map' | 'Privacy:priva' | 'Relation:attRel' | 'Relation:attRelTarget' | 'Relation:insRel' | 'SensitiveData:senseAtt';

export class datasetDescriptorAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['Annotator', 'Annotators', 'Area', 'Attribute', 'Author', 'Authoring', 'Authors', 'Binary', 'Categor', 'Composition', 'DataProvenance', 'DataQuality', 'DataSource', 'DataSources', 'Declaration', 'Dependencies', 'DescriptionDataset', 'Distribution', 'Founder', 'Founders', 'GeneralInfo', 'Instance', 'Instances', 'InstanceStatistics', 'IntegrityRules', 'Labels', 'Maintainer', 'Maintenance', 'Numeri', 'PreProcess', 'Privacy', 'Relation', 'RelationInstances', 'SensitiveData', 'SocialConcerns', 'Tags', 'Uses'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            default: {
                return false;
            }
        }
    }

    getReferenceType(referenceId: datasetDescriptorAstReference): string {
        switch (referenceId) {
            case 'DataSource:mapInstance': {
                return Instance;
            }
            case 'Instance:labels': {
                return Labels;
            }
            case 'Labels:map': {
                return Attribute;
            }
            case 'Privacy:priva': {
                return Attribute;
            }
            case 'Relation:attRel': {
                return Attribute;
            }
            case 'Relation:attRelTarget': {
                return Attribute;
            }
            case 'Relation:insRel': {
                return Instance;
            }
            case 'SensitiveData:senseAtt': {
                return Attribute;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
}

export const reflection = new datasetDescriptorAstReflection();
