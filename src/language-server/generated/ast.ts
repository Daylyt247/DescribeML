/******************************************************************************
 * This file was generated by langium-cli 0.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, Reference, isAstNode } from 'langium';

export interface AccuracyRq extends AstNode {
    readonly $container: Requeriment;
    typeAcc: DataTypeConstraints | RangeConstraints | MandatoryConstraints
}

export const AccuracyRq = 'AccuracyRq';

export function isAccuracyRq(item: unknown): item is AccuracyRq {
    return reflection.isInstance(item, AccuracyRq);
}

export interface Attribute extends AstNode {
    readonly $container: Instance;
    attdesc: string
    attType: ATtype
    completnessAtt: number
    name: string
    unique: number
}

export const Attribute = 'Attribute';

export function isAttribute(item: unknown): item is Attribute {
    return reflection.isInstance(item, Attribute);
}

export interface Author extends AstNode {
    readonly $container: Authors;
    email: string
    name: string
}

export const Author = 'Author';

export function isAuthor(item: unknown): item is Author {
    return reflection.isInstance(item, Author);
}

export interface Authors extends AstNode {
    readonly $container: GeneralInfo;
    authors: Array<Author>
    name: 'Authors:'
}

export const Authors = 'Authors';

export function isAuthors(item: unknown): item is Authors {
    return reflection.isInstance(item, Authors);
}

export interface CompletnessRq extends AstNode {
    readonly $container: Requeriment;
    typeComplet: 'Type' | 'Column Completness' | 'Tuple Completness' | 'Overall Completness' | 'Population Completness'
}

export const CompletnessRq = 'CompletnessRq';

export function isCompletnessRq(item: unknown): item is CompletnessRq {
    return reflection.isInstance(item, CompletnessRq);
}

export interface ConsistencyRq extends AstNode {
    readonly $container: Requeriment;
    typeConst: Sintactic | Semantic
}

export const ConsistencyRq = 'ConsistencyRq';

export function isConsistencyRq(item: unknown): item is ConsistencyRq {
    return reflection.isInstance(item, ConsistencyRq);
}

export interface DatasetDefinition extends AstNode {
    readonly $container: Declaration;
    dependencies: Dependencies
    description: string
    instances: Array<Instances | Instance>
    name: 'Definition:'
    numberInst: number
    privacy: Privacy
    relation: RelationInstances
    splits: string
}

export const DatasetDefinition = 'DatasetDefinition';

export function isDatasetDefinition(item: unknown): item is DatasetDefinition {
    return reflection.isInstance(item, DatasetDefinition);
}

export interface DataTypeConstraints extends AstNode {
    readonly $container: AccuracyRq;
    att: Reference<Attribute>
    dataType: DataTypes
}

export const DataTypeConstraints = 'DataTypeConstraints';

export function isDataTypeConstraints(item: unknown): item is DataTypeConstraints {
    return reflection.isInstance(item, DataTypeConstraints);
}

export interface Declaration extends AstNode {
    readonly $container: DescriptionDataset;
    definition: DatasetDefinition
    metainfo: GeneralInfo
    name: string
    requeriments: Requeriments
}

export const Declaration = 'Declaration';

export function isDeclaration(item: unknown): item is Declaration {
    return reflection.isInstance(item, Declaration);
}

export interface Dependencies extends AstNode {
    readonly $container: DatasetDefinition;
    archival: string
    limit: string
    restriction: string
}

export const Dependencies = 'Dependencies';

export function isDependencies(item: unknown): item is Dependencies {
    return reflection.isInstance(item, Dependencies);
}

export interface DescriptionDataset extends AstNode {
    elements: Array<Declaration>
}

export const DescriptionDataset = 'DescriptionDataset';

export function isDescriptionDataset(item: unknown): item is DescriptionDataset {
    return reflection.isInstance(item, DescriptionDataset);
}

export interface Founder extends AstNode {
    readonly $container: Founders;
    grantor: string
    name: string
    type: FoundersType
}

export const Founder = 'Founder';

export function isFounder(item: unknown): item is Founder {
    return reflection.isInstance(item, Founder);
}

export interface Founders extends AstNode {
    readonly $container: GeneralInfo;
    founders: Array<Founder>
    name: 'Founders:'
}

export const Founders = 'Founders';

export function isFounders(item: unknown): item is Founders {
    return reflection.isInstance(item, Founders);
}

export interface GeneralInfo extends AstNode {
    readonly $container: Declaration;
    autohring: Array<Authors>
    description: string
    founding: Array<Founders>
    licence: string
    maintenance: Array<Maintenance>
    title: string
    version: string
}

export const GeneralInfo = 'GeneralInfo';

export function isGeneralInfo(item: unknown): item is GeneralInfo {
    return reflection.isInstance(item, GeneralInfo);
}

export interface Instance extends AstNode {
    readonly $container: DatasetDefinition | Instances;
    attributes: Array<Attribute>
    descript: string
    name: string
    numIns: number
    offDiscussion: string
    procGroups: string
    senseAtt?: Reference<Attribute>
    type: InsType
}

export const Instance = 'Instance';

export function isInstance(item: unknown): item is Instance {
    return reflection.isInstance(item, Instance);
}

export interface Instances extends AstNode {
    readonly $container: DatasetDefinition;
    instances: Array<Instance>
    name: 'Instances:'
}

export const Instances = 'Instances';

export function isInstances(item: unknown): item is Instances {
    return reflection.isInstance(item, Instances);
}

export interface Maintainer extends AstNode {
    readonly $container: Maintenance;
    email: string
    name: string
}

export const Maintainer = 'Maintainer';

export function isMaintainer(item: unknown): item is Maintainer {
    return reflection.isInstance(item, Maintainer);
}

export interface Maintenance extends AstNode {
    readonly $container: GeneralInfo;
    contribGuides: string
    dataRetention: string
    erratum: string
    maintainers: Array<Maintainer>
    name: 'Maintenance:'
    support: string
}

export const Maintenance = 'Maintenance';

export function isMaintenance(item: unknown): item is Maintenance {
    return reflection.isInstance(item, Maintenance);
}

export interface MandatoryConstraints extends AstNode {
    readonly $container: AccuracyRq;
    att: Reference<Attribute>
    mandatory: string
}

export const MandatoryConstraints = 'MandatoryConstraints';

export function isMandatoryConstraints(item: unknown): item is MandatoryConstraints {
    return reflection.isInstance(item, MandatoryConstraints);
}

export interface Privacy extends AstNode {
    readonly $container: DatasetDefinition;
    indident: 'yes'
    legal: string
}

export const Privacy = 'Privacy';

export function isPrivacy(item: unknown): item is Privacy {
    return reflection.isInstance(item, Privacy);
}

export interface RangeConstraints extends AstNode {
    readonly $container: AccuracyRq;
    att: Reference<Attribute>
    highrange: number
    lowrange: number
}

export const RangeConstraints = 'RangeConstraints';

export function isRangeConstraints(item: unknown): item is RangeConstraints {
    return reflection.isInstance(item, RangeConstraints);
}

export interface Relation extends AstNode {
    readonly $container: RelationInstances;
    attRel?: Reference<Attribute>
    attRelTarget?: Reference<Attribute>
    insRel?: Reference<Instance>
    name: string
}

export const Relation = 'Relation';

export function isRelation(item: unknown): item is Relation {
    return reflection.isInstance(item, Relation);
}

export interface RelationInstances extends AstNode {
    readonly $container: DatasetDefinition;
    relation: Array<Relation>
}

export const RelationInstances = 'RelationInstances';

export function isRelationInstances(item: unknown): item is RelationInstances {
    return reflection.isInstance(item, RelationInstances);
}

export interface Requeriment extends AstNode {
    readonly $container: Requeriments;
    action: AccuracyRq | ConsistencyRq | CompletnessRq
    name: string
    reporter: Reference<Author>
}

export const Requeriment = 'Requeriment';

export function isRequeriment(item: unknown): item is Requeriment {
    return reflection.isInstance(item, Requeriment);
}

export interface Requeriments extends AstNode {
    readonly $container: Declaration;
    requeriments: Array<Requeriment>
}

export const Requeriments = 'Requeriments';

export function isRequeriments(item: unknown): item is Requeriments {
    return reflection.isInstance(item, Requeriments);
}

export interface Semantic extends AstNode {
    readonly $container: ConsistencyRq;
    attObject: Reference<Attribute>
    distribution: string
}

export const Semantic = 'Semantic';

export function isSemantic(item: unknown): item is Semantic {
    return reflection.isInstance(item, Semantic);
}

export interface Sintactic extends AstNode {
    readonly $container: ConsistencyRq;
    attObject: Reference<Attribute>
    attTarget: Reference<Attribute>
    operation: Operation
}

export const Sintactic = 'Sintactic';

export function isSintactic(item: unknown): item is Sintactic {
    return reflection.isInstance(item, Sintactic);
}

export type QualifiedName = string

export type DataTypes = 'String' | 'Integer' | 'Boolean' | 'Other'

export type ATtype = 'int' | 'string' | 'bool'

export type InsType = 'people' | 'images' | 'raw' | 'features' | 'other'

export type FoundersType = 'private' | 'public' | 'mixed'

export type Operation = '<' | '>' | '=' | '!=' | '+' | '-'

export type datasetDescriptorAstType = 'AccuracyRq' | 'Attribute' | 'Author' | 'Authors' | 'CompletnessRq' | 'ConsistencyRq' | 'DatasetDefinition' | 'DataTypeConstraints' | 'Declaration' | 'Dependencies' | 'DescriptionDataset' | 'Founder' | 'Founders' | 'GeneralInfo' | 'Instance' | 'Instances' | 'Maintainer' | 'Maintenance' | 'MandatoryConstraints' | 'Privacy' | 'RangeConstraints' | 'Relation' | 'RelationInstances' | 'Requeriment' | 'Requeriments' | 'Semantic' | 'Sintactic';

export type datasetDescriptorAstReference = 'DataTypeConstraints:att' | 'Instance:senseAtt' | 'MandatoryConstraints:att' | 'RangeConstraints:att' | 'Relation:attRel' | 'Relation:attRelTarget' | 'Relation:insRel' | 'Requeriment:reporter' | 'Semantic:attObject' | 'Sintactic:attObject' | 'Sintactic:attTarget';

export class datasetDescriptorAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['AccuracyRq', 'Attribute', 'Author', 'Authors', 'CompletnessRq', 'ConsistencyRq', 'DatasetDefinition', 'DataTypeConstraints', 'Declaration', 'Dependencies', 'DescriptionDataset', 'Founder', 'Founders', 'GeneralInfo', 'Instance', 'Instances', 'Maintainer', 'Maintenance', 'MandatoryConstraints', 'Privacy', 'RangeConstraints', 'Relation', 'RelationInstances', 'Requeriment', 'Requeriments', 'Semantic', 'Sintactic'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            default: {
                return false;
            }
        }
    }

    getReferenceType(referenceId: datasetDescriptorAstReference): string {
        switch (referenceId) {
            case 'DataTypeConstraints:att': {
                return Attribute;
            }
            case 'Instance:senseAtt': {
                return Attribute;
            }
            case 'MandatoryConstraints:att': {
                return Attribute;
            }
            case 'RangeConstraints:att': {
                return Attribute;
            }
            case 'Relation:attRel': {
                return Attribute;
            }
            case 'Relation:attRelTarget': {
                return Attribute;
            }
            case 'Relation:insRel': {
                return Instance;
            }
            case 'Requeriment:reporter': {
                return Author;
            }
            case 'Semantic:attObject': {
                return Attribute;
            }
            case 'Sintactic:attObject': {
                return Attribute;
            }
            case 'Sintactic:attTarget': {
                return Attribute;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
}

export const reflection = new datasetDescriptorAstReflection();
