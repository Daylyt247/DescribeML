/******************************************************************************
 * This file was generated by langium-cli 0.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, Reference, ReferenceInfo, isAstNode, TypeMetaData } from 'langium';

export type AnnotationType = '3D cuboids' | 'Bounding boxes' | 'Content and textual categorization' | 'Entity annotation' | 'Image and video annotations' | 'Landmark and key-point' | 'Lines and splines' | 'Polygonal segmentation' | 'Semantinc Segmentation';

export type AttributeSymmetry = 'Asymmetric' | 'Symmetric';

export type BooleanAnswer = 'No' | 'Yes';

export type CommonLicences = 'AGPL 3.0 (GNU Affero General Public License 3.0)' | 'CC BY 3.0 (Attribution 3.0 Unported)' | 'CC BY 3.0 IGO (Attribution 3.0 IGO)' | 'CC BY 4.0 (Attribution 4.0 International)' | 'CC BY-NC 4.0 (Attribution-NonCommercial 4.0 International)' | 'CC BY-NC-ND 4.0 (Attribution-NonCommercial-NoDerivatives 4.0 International)' | 'CC BY-NC-SA 3.0 IGO (Attribution-NonCommercial-ShareAlike 3.0 IGO)' | 'CC BY-NC-SA 4.0' | 'CC BY-ND 4.0 (Attribution-NoDerivatives 4.0 International)' | 'CC BY-SA 3.0' | 'CC BY-SA 4.0' | 'CC0: Public Domain' | 'Community Data License Agreement - Permissive - Version 1.0' | 'Community Data License Agreement - Sharing - Version 1.0' | 'Community Data License' | 'Creative Commons' | 'Database: Open Database, Contents: Database Contents' | 'Database: Open Database, Contents: Â© Original Authors' | 'EU ODP Legal Notice' | 'FDL 1.3 (GNU Free Documentation License 1.3)' | 'GPL 2' | 'GPL' | 'LGPL 3.0 (GNU Lesser General Public License 3.0)' | 'Non-declared' | 'ODC-BY 1.0 (ODC Attribution License)' | 'Open Data Commons' | 'PDDL (ODC Public Domain Dedication and Licence)' | 'Reddit API Terms' | 'Special' | 'The Montreal data licence' | 'U.S. Government Works' | 'World Bank Dataset Terms of Use';

export type Dash = string;

export type DataProcess = 'Data Augmentation' | 'Data Normalization' | 'Data reduction' | 'Missing Values' | 'Others' | 'Outlier Filtering' | 'Remove Duplicates' | 'Sampling';

export type DataTypes = 'Boolean' | 'Integer' | 'Other' | 'String';

export type DateYear = string;

export type DOI = string;

export type EmailType = string;

export type FundersType = 'mixed' | 'private' | 'public';

export type GatherType = 'API' | 'Manual Human Curator' | 'Others' | 'Scrapping' | 'Sensors' | 'Software';

export type HistogramType = string;

export type InstanceType = 'Graph' | 'Ordered' | 'Other' | 'Record-Data' | 'Time-Series';

export type MLTasks = 'Automatic-Speech-Recognition' | 'Code Generation' | 'Evaluation of language models' | 'Inclusive Language' | 'Information Retrieval' | 'Language-model' | 'Semantic Search' | 'Summarization' | 'Text Neutralization' | 'Text2Text generation' | 'Token Classification' | 'Translation' | 'abstractive-qa' | 'audio-classification' | 'automatic-speech-recognition' | 'caption-retrieval' | 'classification' | 'closed-domain-abstrative-qa' | 'code-generation' | 'computer-vision' | 'conditional-text-generation' | 'conversational' | 'cross-language-transcription' | 'crowdsourced' | 'data-integration' | 'data-to-text' | 'deduplication' | 'dialog-response-generation' | 'email subject' | 'entity-extraction' | 'feature-extraction' | 'fill-mask' | 'generative-modelling' | 'gpt-3' | 'grammatical error correction' | 'image' | 'image-captioning' | 'image-classification' | 'image-enhancement' | 'image-retrieval' | 'image-segmentation' | 'image-to-text' | 'influence-attribution' | 'information-retrieval' | 'language-modeling' | 'language-modelling' | 'linear-regression' | 'long-texts' | 'machine translation' | 'machine-translation' | 'masked-language-modeling' | 'meeting title' | 'multi-class classification' | 'multiple-choice' | 'named-entity-disambiguation' | 'named-entity-recognition' | 'natural-language-inference' | 'neural-machine-translation' | 'news-classification' | 'object-detection' | 'one liner summary' | 'other' | 'other-test' | 'other-text-search' | 'paraphrase detection' | 'paraphrase' | 'paraphrasing' | 'patents' | 'query-paraphrasing' | 'question-answering' | 'question-answering-retrieval' | 'question-generation' | 'question-pairing' | 'question_answering' | 'reasoning' | 'sentence-similarity' | 'sentiment-analysis' | 'sequence-modeling' | 'sequence-modelling' | 'sequence2sequence' | 'simplification' | 'speech-processing' | 'speech-synthesis' | 'structure-prediction' | 'summarization' | 'super-resolution' | 'symbolic-regression' | 'syntactic-evaluation' | 'table-question-answering' | 'table-to-text' | 'tabular-classification' | 'tabular-to-text' | 'text' | 'text-classification' | 'text-generation' | 'text-generation-other-code-modeling' | 'text-generation-other-common-sense-inference' | 'text-generation-other-discourse-analysis' | 'text-mining' | 'text-regression' | 'text-retrieval' | 'text-scoring' | 'text-to-slide' | 'text-to-speech' | 'text-to-structured' | 'text-to-tabular' | 'text2text-generation' | 'text_classification' | 'textual-entailment' | 'time-series-forecasting' | 'token-classification' | 'topic modeling' | 'topic-classification' | 'transkation' | 'translation' | 'tts' | 'unpaired-image-to-image-translation' | 'video-captionning' | 'visual-question-answering' | 'zero-shot-classification' | 'zero-shot-information-retrieval' | 'zero-shot-retrieval';

export type Operators = 'bigger' | 'diferent' | 'equal' | 'equal+bigger' | 'litle' | 'minus' | 'more';

export type QualifiedName = string;

export type RightsData = 'Access' | 'Distribute' | 'Re-Represent' | 'Tagging';

export type RightsModel = 'Benchmark' | 'Internal Use' | 'Model Commercialization' | 'Output Commercialization' | 'Publish' | 'Research';

export type SampleType = 'Cluster Sampling' | 'Haphazard Sampling' | 'Multi-stage Sampling' | 'Other' | 'Stratified Sampling' | 'Systematic Sampling' | 'Weighted Sampling';

export type SocialIssueType = 'Bias' | 'Privacy' | 'Sensitive Data' | 'Social Impact';

export type SpeechModality = 'spoken/signed' | 'written';

export type SpeechSyncrony = 'asynchronous intercation' | 'synchronous interaction';

export type SpeechType = 'Scripted/edited' | 'spontaneous';

export type StringNumberType = string;

export type TeamType = 'Contractors' | 'Crowdsourcing' | 'External' | 'Internal';

export interface Applications extends AstNode {
    readonly $container: Metadata;
    bachmarking?: Benchmarking
    future: Array<string>
    name: 'Applications:'
    past: Array<string>
    recommend: Array<string>
    repo?: string
}

export const Applications = 'Applications';

export function isApplications(item: unknown): item is Applications {
    return reflection.isInstance(item, Applications);
}

export interface Area extends AstNode {
    readonly $container: Areas;
    name: string
}

export const Area = 'Area';

export function isArea(item: unknown): item is Area {
    return reflection.isInstance(item, Area);
}

export interface Areas extends AstNode {
    readonly $container: Description;
    areas: Array<Area>
    name: 'Areas:'
}

export const Areas = 'Areas';

export function isAreas(item: unknown): item is Areas {
    return reflection.isInstance(item, Areas);
}

export interface Attribute extends AstNode {
    readonly $container: DataInstance;
    attdesc: string
    attType?: Categor | Numeri
    count?: number
    label?: Reference<Labels>
    name: string
    unique?: number
}

export const Attribute = 'Attribute';

export function isAttribute(item: unknown): item is Attribute {
    return reflection.isInstance(item, Attribute);
}

export interface Author extends AstNode {
    readonly $container: Authors;
    contact?: string
    email?: EmailType
    name: string
}

export const Author = 'Author';

export function isAuthor(item: unknown): item is Author {
    return reflection.isInstance(item, Author);
}

export interface Authoring extends AstNode {
    readonly $container: Metadata;
    authors: Array<Authors>
    contribGuides?: string
    dataRetention?: string
    erratum?: BooleanAnswer | string
    founding: Array<Founders>
    maintainers: Array<Maintainer>
    name: 'Authoring:'
    support?: string
}

export const Authoring = 'Authoring';

export function isAuthoring(item: unknown): item is Authoring {
    return reflection.isInstance(item, Authoring);
}

export interface Authors extends AstNode {
    readonly $container: Authoring;
    authors: Array<Author>
    name: 'Authors:'
}

export const Authors = 'Authors';

export function isAuthors(item: unknown): item is Authors {
    return reflection.isInstance(item, Authors);
}

export interface Benchmarking extends AstNode {
    readonly $container: Applications;
    acurracy?: number
    f1?: number
    modelName?: string
    name: 'Benchmarking:'
    precision?: number
    recall?: number
    reference?: string
    taskName?: Task
}

export const Benchmarking = 'Benchmarking';

export function isBenchmarking(item: unknown): item is Benchmarking {
    return reflection.isInstance(item, Benchmarking);
}

export interface Binary extends AstNode {
    readonly $container: Categor;
    attspar: number
    sym: AttributeSymmetry
}

export const Binary = 'Binary';

export function isBinary(item: unknown): item is Binary {
    return reflection.isInstance(item, Binary);
}

export interface Categor extends AstNode {
    readonly $container: Attribute;
    binary?: Binary
    catdist: Array<StringNumberType> | StringNumberType
    chisquared?: ChiSquare
    complet?: number
    firstrows?: FirstRows
    lenghthistorgram: Array<HistogramType> | HistogramType
    maxlenght?: number
    medianlenght?: number
    metrics: Array<QualityMetric>
    minlenght?: number
    missingv?: number
    mode?: string
    name: 'Categorical'
    unique?: number
    uniqueper?: number
}

export const Categor = 'Categor';

export function isCategor(item: unknown): item is Categor {
    return reflection.isInstance(item, Categor);
}

export interface ChiSquare extends AstNode {
    readonly $container: Categor;
    pvalue?: number
    statistic?: number
}

export const ChiSquare = 'ChiSquare';

export function isChiSquare(item: unknown): item is ChiSquare {
    return reflection.isInstance(item, ChiSquare);
}

export interface Citation extends AstNode {
    readonly $container: Metadata;
    authorsPaper?: Citeauthors
    citeText?: string
    doi?: DoiCite
    keywords: Array<Keyword>
    name: 'Citation:'
    publisher?: Publisher
    title?: Title
    url?: CiteUrl
    year?: number
}

export const Citation = 'Citation';

export function isCitation(item: unknown): item is Citation {
    return reflection.isInstance(item, Citation);
}

export interface Citeauthors extends AstNode {
    readonly $container: Citation;
    name: string
}

export const Citeauthors = 'Citeauthors';

export function isCiteauthors(item: unknown): item is Citeauthors {
    return reflection.isInstance(item, Citeauthors);
}

export interface CiteUrl extends AstNode {
    readonly $container: Citation;
    name: string
}

export const CiteUrl = 'CiteUrl';

export function isCiteUrl(item: unknown): item is CiteUrl {
    return reflection.isInstance(item, CiteUrl);
}

export interface Composition extends AstNode {
    readonly $container: Declaration;
    compodesc: Array<string>
    dependencies?: Dependencies
    instances: Array<DataInstances>
    name: 'Composition:'
    numberInst?: number
    relation?: RelationInstances
    sample?: 'NO' | Sample
    splits?: string
}

export const Composition = 'Composition';

export function isComposition(item: unknown): item is Composition {
    return reflection.isInstance(item, Composition);
}

export interface ConsistencyRules extends AstNode {
    readonly $container: DataInstance;
    attr2?: Reference<Attribute>
    attrule1: Reference<Attribute>
    comparator: Operators
    instance1: Reference<DataInstance>
    value?: number
}

export const ConsistencyRules = 'ConsistencyRules';

export function isConsistencyRules(item: unknown): item is ConsistencyRules {
    return reflection.isInstance(item, ConsistencyRules);
}

export interface Correlations extends AstNode {
    readonly $container: Statistics;
    cramers: Array<StringNumberType> | StringNumberType
    kendall: Array<StringNumberType> | StringNumberType
    pearson: Array<StringNumberType> | StringNumberType
    phik: Array<StringNumberType> | StringNumberType
    spearman: Array<StringNumberType> | StringNumberType
}

export const Correlations = 'Correlations';

export function isCorrelations(item: unknown): item is Correlations {
    return reflection.isInstance(item, Correlations);
}

export interface DataInstance extends AstNode {
    readonly $container: DataInstances;
    attributes: Array<Attribute>
    attrnum: number
    descript: string
    name: string
    numIns?: number
    rules: Array<ConsistencyRules>
    statistics: Array<Statistics>
    type: InstanceType
}

export const DataInstance = 'DataInstance';

export function isDataInstance(item: unknown): item is DataInstance {
    return reflection.isInstance(item, DataInstance);
}

export interface DataInstances extends AstNode {
    readonly $container: Composition;
    instances: Array<DataInstance>
    name: 'Data Instances:'
}

export const DataInstances = 'DataInstances';

export function isDataInstances(item: unknown): item is DataInstances {
    return reflection.isInstance(item, DataInstances);
}

export interface Dates extends AstNode {
    readonly $container: Metadata;
    datesP?: PublishedDate
    datesR: ReleaseDate
    datesU?: UpdateDate
    name: 'Dates:'
}

export const Dates = 'Dates';

export function isDates(item: unknown): item is Dates {
    return reflection.isInstance(item, Dates);
}

export interface Declaration extends AstNode {
    readonly $container: DescriptionDataset;
    composition?: Composition
    generalinfo: Metadata
    name: string
    provenance?: Provenance
    socialConcerns?: SocialConcerns
}

export const Declaration = 'Declaration';

export function isDeclaration(item: unknown): item is Declaration {
    return reflection.isInstance(item, Declaration);
}

export interface Demographics extends AstNode {
    readonly $container: GatheringProcess | Team;
    age?: number
    country?: string
    disordered?: string
    gender?: string
    native?: string
    number?: number
    race?: string
    status?: string
    training?: string
}

export const Demographics = 'Demographics';

export function isDemographics(item: unknown): item is Demographics {
    return reflection.isInstance(item, Demographics);
}

export interface Dependencies extends AstNode {
    readonly $container: Composition;
    archival?: string
    desc: string
    limit?: string
    restriction?: string
}

export const Dependencies = 'Dependencies';

export function isDependencies(item: unknown): item is Dependencies {
    return reflection.isInstance(item, Dependencies);
}

export interface Description extends AstNode {
    readonly $container: Metadata;
    area?: Areas
    desc?: string
    descriptionGaps?: string
    descriptionpurpose?: string
    descriptionTasks: Array<Task>
    name: 'Description:'
    tags?: Tags
    tasks?: 'Tasks:'
}

export const Description = 'Description';

export function isDescription(item: unknown): item is Description {
    return reflection.isInstance(item, Description);
}

export interface DescriptionDataset extends AstNode {
    elements: Array<Declaration>
}

export const DescriptionDataset = 'DescriptionDataset';

export function isDescriptionDataset(item: unknown): item is DescriptionDataset {
    return reflection.isInstance(item, DescriptionDataset);
}

export interface Distribution extends AstNode {
    readonly $container: Metadata;
    addCond?: string
    attribution?: string
    licence?: CommonLicences
    name: 'Distribution:'
    public?: BooleanAnswer
    rights?: RightsData
    rightsModels?: RightsModel
    thirdParties?: string
}

export const Distribution = 'Distribution';

export function isDistribution(item: unknown): item is Distribution {
    return reflection.isInstance(item, Distribution);
}

export interface DoiCite extends AstNode {
    readonly $container: Citation;
    name: DOI
}

export const DoiCite = 'DoiCite';

export function isDoiCite(item: unknown): item is DoiCite {
    return reflection.isInstance(item, DoiCite);
}

export interface FirstRows extends AstNode {
    readonly $container: Categor;
    rows: Array<string>
}

export const FirstRows = 'FirstRows';

export function isFirstRows(item: unknown): item is FirstRows {
    return reflection.isInstance(item, FirstRows);
}

export interface Founders extends AstNode {
    readonly $container: Authoring;
    funders: Array<Funder>
    name: 'Funders:'
}

export const Founders = 'Founders';

export function isFounders(item: unknown): item is Founders {
    return reflection.isInstance(item, Founders);
}

export interface Funder extends AstNode {
    readonly $container: Founders;
    grantor?: string
    name: string
    type: FundersType
}

export const Funder = 'Funder';

export function isFunder(item: unknown): item is Funder {
    return reflection.isInstance(item, Funder);
}

export interface GatheringProcess extends AstNode {
    readonly $container: GatheringProcesses;
    desc: string
    gatherDates?: string
    gatheringTeam?: Team
    how?: GatherType
    labelSocialIssues?: Reference<SocialIssue>
    mapInstance?: Reference<DataInstance>
    name: string
    processDemo?: Demographics
    requeriments: Array<Requeriments>
    source: Source
    when?: string
}

export const GatheringProcess = 'GatheringProcess';

export function isGatheringProcess(item: unknown): item is GatheringProcess {
    return reflection.isInstance(item, GatheringProcess);
}

export interface GatheringProcesses extends AstNode {
    readonly $container: Provenance;
    name: 'Gathering Processes:'
    processes: Array<GatheringProcess>
}

export const GatheringProcesses = 'GatheringProcesses';

export function isGatheringProcesses(item: unknown): item is GatheringProcesses {
    return reflection.isInstance(item, GatheringProcesses);
}

export interface GoldenQuestion extends AstNode {
    readonly $container: Validation;
    answer: number
    question: string
}

export const GoldenQuestion = 'GoldenQuestion';

export function isGoldenQuestion(item: unknown): item is GoldenQuestion {
    return reflection.isInstance(item, GoldenQuestion);
}

export interface Infrastructure extends AstNode {
    readonly $container: LabelingProcess;
    language?: string
    other?: string
    platform?: string
    tool?: string
    version?: string
}

export const Infrastructure = 'Infrastructure';

export function isInfrastructure(item: unknown): item is Infrastructure {
    return reflection.isInstance(item, Infrastructure);
}

export interface Keyword extends AstNode {
    readonly $container: Citation;
    name: string
}

export const Keyword = 'Keyword';

export function isKeyword(item: unknown): item is Keyword {
    return reflection.isInstance(item, Keyword);
}

export interface LabelingProcess extends AstNode {
    readonly $container: LabelingProcesses;
    desc: string
    infra?: Infrastructure
    labelingTeam?: Team
    labelSocialIssues?: Reference<SocialIssue>
    name: string
    requeriments: Array<Requeriments>
    type?: AnnotationType
    validation?: Validation
}

export const LabelingProcess = 'LabelingProcess';

export function isLabelingProcess(item: unknown): item is LabelingProcess {
    return reflection.isInstance(item, LabelingProcess);
}

export interface LabelingProcesses extends AstNode {
    readonly $container: Provenance;
    labprocesses: Array<LabelingProcess>
    name: 'LabelingProcesses:'
}

export const LabelingProcesses = 'LabelingProcesses';

export function isLabelingProcesses(item: unknown): item is LabelingProcesses {
    return reflection.isInstance(item, LabelingProcesses);
}

export interface LabelRequeriments extends AstNode {
    requeriments: Array<Requeriments>
}

export const LabelRequeriments = 'LabelRequeriments';

export function isLabelRequeriments(item: unknown): item is LabelRequeriments {
    return reflection.isInstance(item, LabelRequeriments);
}

export interface Labels extends AstNode {
    desc: string
    map?: Reference<Attribute>
    name: string
}

export const Labels = 'Labels';

export function isLabels(item: unknown): item is Labels {
    return reflection.isInstance(item, Labels);
}

export interface Maintainer extends AstNode {
    readonly $container: Authoring;
    email: EmailType
    name: string
}

export const Maintainer = 'Maintainer';

export function isMaintainer(item: unknown): item is Maintainer {
    return reflection.isInstance(item, Maintainer);
}

export interface Metadata extends AstNode {
    readonly $container: Declaration;
    authoring: Authoring
    citation?: Citation
    dates?: Dates
    desc?: Description
    distribution?: Distribution
    ident: string
    name: 'Metadata:'
    title: string
    uses?: Applications
    version: string
}

export const Metadata = 'Metadata';

export function isMetadata(item: unknown): item is Metadata {
    return reflection.isInstance(item, Metadata);
}

export interface Numeri extends AstNode {
    readonly $container: Attribute;
    iqr?: number
    max?: number
    mean?: number
    median?: number
    metrics: Array<QualityMetric>
    min?: number
    name: 'Numerical'
    quartiles?: Quartile
    std?: number
}

export const Numeri = 'Numeri';

export function isNumeri(item: unknown): item is Numeri {
    return reflection.isInstance(item, Numeri);
}

export interface PairCorrelation extends AstNode {
    readonly $container: Statistics;
    attr1?: Reference<Attribute>
    attr2?: Reference<Attribute>
    from?: string
    rationale?: string
}

export const PairCorrelation = 'PairCorrelation';

export function isPairCorrelation(item: unknown): item is PairCorrelation {
    return reflection.isInstance(item, PairCorrelation);
}

export interface PreProcess extends AstNode {
    readonly $container: PreProcesses;
    desc: string
    labelSocialIssues?: Reference<SocialIssue>
    name: string
    type: DataProcess
}

export const PreProcess = 'PreProcess';

export function isPreProcess(item: unknown): item is PreProcess {
    return reflection.isInstance(item, PreProcess);
}

export interface PreProcesses extends AstNode {
    readonly $container: Provenance;
    name: 'Preprocesses:'
    preprocesses: Array<PreProcess>
}

export const PreProcesses = 'PreProcesses';

export function isPreProcesses(item: unknown): item is PreProcesses {
    return reflection.isInstance(item, PreProcesses);
}

export interface Provenance extends AstNode {
    readonly $container: Declaration;
    curation: string
    gathering: Array<GatheringProcesses>
    labeling: Array<LabelingProcesses>
    name: 'Data Provenance:'
    other: Array<PreProcesses>
}

export const Provenance = 'Provenance';

export function isProvenance(item: unknown): item is Provenance {
    return reflection.isInstance(item, Provenance);
}

export interface PublishedDate extends AstNode {
    readonly $container: Dates;
    datesP: DateYear
    name: 'Published Date:'
}

export const PublishedDate = 'PublishedDate';

export function isPublishedDate(item: unknown): item is PublishedDate {
    return reflection.isInstance(item, PublishedDate);
}

export interface Publisher extends AstNode {
    readonly $container: Citation;
    name: string
}

export const Publisher = 'Publisher';

export function isPublisher(item: unknown): item is Publisher {
    return reflection.isInstance(item, Publisher);
}

export interface QualityMetric extends AstNode {
    readonly $container: Categor | Numeri | Statistics;
    balance?: string
    complet?: number
    noisy?: string
    sparsity?: number
}

export const QualityMetric = 'QualityMetric';

export function isQualityMetric(item: unknown): item is QualityMetric {
    return reflection.isInstance(item, QualityMetric);
}

export interface Quartile extends AstNode {
    readonly $container: Numeri;
    q1: number
    q2: number
    q3: number
    q4: number
}

export const Quartile = 'Quartile';

export function isQuartile(item: unknown): item is Quartile {
    return reflection.isInstance(item, Quartile);
}

export interface Relation extends AstNode {
    readonly $container: RelationInstances;
    attRel?: Reference<Attribute>
    attRelTarget?: Reference<Attribute>
    insRel?: Reference<DataInstance>
    name?: string
}

export const Relation = 'Relation';

export function isRelation(item: unknown): item is Relation {
    return reflection.isInstance(item, Relation);
}

export interface RelationInstances extends AstNode {
    readonly $container: Composition;
    relation: Array<Relation>
}

export const RelationInstances = 'RelationInstances';

export function isRelationInstances(item: unknown): item is RelationInstances {
    return reflection.isInstance(item, RelationInstances);
}

export interface ReleaseDate extends AstNode {
    readonly $container: Dates;
    datesR: DateYear
    name: 'Release Date:'
}

export const ReleaseDate = 'ReleaseDate';

export function isReleaseDate(item: unknown): item is ReleaseDate {
    return reflection.isInstance(item, ReleaseDate);
}

export interface Requeriments extends AstNode {
    readonly $container: GatheringProcess | LabelRequeriments | LabelingProcess | Validation;
    req: string
}

export const Requeriments = 'Requeriments';

export function isRequeriments(item: unknown): item is Requeriments {
    return reflection.isInstance(item, Requeriments);
}

export interface Sample extends AstNode {
    readonly $container: Composition;
    charact: Array<SamplingCharacteristics>
    criteria?: string
    name: 'YES'
    type?: SampleType
}

export const Sample = 'Sample';

export function isSample(item: unknown): item is Sample {
    return reflection.isInstance(item, Sample);
}

export interface SamplingCharacteristics extends AstNode {
    readonly $container: Sample;
    distribution: number
    mean: string
    rate: number
    std: number
    total: number
    variation: number
}

export const SamplingCharacteristics = 'SamplingCharacteristics';

export function isSamplingCharacteristics(item: unknown): item is SamplingCharacteristics {
    return reflection.isInstance(item, SamplingCharacteristics);
}

export interface SocialConcerns extends AstNode {
    readonly $container: Declaration;
    desc?: string
    name: 'Social Concerns:'
    socialIssues: Array<SocialIssue>
}

export const SocialConcerns = 'SocialConcerns';

export function isSocialConcerns(item: unknown): item is SocialConcerns {
    return reflection.isInstance(item, SocialConcerns);
}

export interface SocialIssue extends AstNode {
    readonly $container: SocialConcerns;
    desc: string
    IssueType: SocialIssueType
    name: string
    offDiscussion?: string
    procGroups?: BooleanAnswer
    senseAtt?: Reference<Attribute>
}

export const SocialIssue = 'SocialIssue';

export function isSocialIssue(item: unknown): item is SocialIssue {
    return reflection.isInstance(item, SocialIssue);
}

export interface Source extends AstNode {
    readonly $container: GatheringProcess;
    name: string
    noise: Array<string>
    sourcedesc: string
}

export const Source = 'Source';

export function isSource(item: unknown): item is Source {
    return reflection.isInstance(item, Source);
}

export interface SpeechSitatuion extends AstNode {
    name?: SpeechModality | SpeechSyncrony | SpeechType | string
}

export const SpeechSitatuion = 'SpeechSitatuion';

export function isSpeechSitatuion(item: unknown): item is SpeechSitatuion {
    return reflection.isInstance(item, SpeechSitatuion);
}

export interface Statistics extends AstNode {
    readonly $container: DataInstance;
    correlations?: Correlations
    metric: Array<QualityMetric>
    pair: Array<PairCorrelation>
}

export const Statistics = 'Statistics';

export function isStatistics(item: unknown): item is Statistics {
    return reflection.isInstance(item, Statistics);
}

export interface Tag extends AstNode {
    readonly $container: Tags;
    name: string
}

export const Tag = 'Tag';

export function isTag(item: unknown): item is Tag {
    return reflection.isInstance(item, Tag);
}

export interface Tags extends AstNode {
    readonly $container: Description;
    name: 'Tags:'
    tags: Array<Tag>
}

export const Tags = 'Tags';

export function isTags(item: unknown): item is Tags {
    return reflection.isInstance(item, Tags);
}

export interface Task extends AstNode {
    readonly $container: Benchmarking | Description | Tasks;
    name: MLTasks
}

export const Task = 'Task';

export function isTask(item: unknown): item is Task {
    return reflection.isInstance(item, Task);
}

export interface Tasks extends AstNode {
    descriptionTasks: Array<Task>
    name: 'Tasks:'
}

export const Tasks = 'Tasks';

export function isTasks(item: unknown): item is Tasks {
    return reflection.isInstance(item, Tasks);
}

export interface Team extends AstNode {
    readonly $container: GatheringProcess | LabelingProcess;
    gatherType: TeamType
    teamDemographics: Demographics
    who: string
}

export const Team = 'Team';

export function isTeam(item: unknown): item is Team {
    return reflection.isInstance(item, Team);
}

export interface Title extends AstNode {
    readonly $container: Citation;
    name: string
}

export const Title = 'Title';

export function isTitle(item: unknown): item is Title {
    return reflection.isInstance(item, Title);
}

export interface UpdateDate extends AstNode {
    readonly $container: Dates;
    datesU: DateYear
    name: 'Updated Date:'
}

export const UpdateDate = 'UpdateDate';

export function isUpdateDate(item: unknown): item is UpdateDate {
    return reflection.isInstance(item, UpdateDate);
}

export interface Validation extends AstNode {
    readonly $container: LabelingProcess;
    goldenquestions?: GoldenQuestion
    method?: string
    requeriments: Array<Requeriments>
    validationDates?: string
}

export const Validation = 'Validation';

export function isValidation(item: unknown): item is Validation {
    return reflection.isInstance(item, Validation);
}

export type DatasetDescriptorAstType = 'Applications' | 'Area' | 'Areas' | 'Attribute' | 'Author' | 'Authoring' | 'Authors' | 'Benchmarking' | 'Binary' | 'Categor' | 'ChiSquare' | 'Citation' | 'CiteUrl' | 'Citeauthors' | 'Composition' | 'ConsistencyRules' | 'Correlations' | 'DataInstance' | 'DataInstances' | 'Dates' | 'Declaration' | 'Demographics' | 'Dependencies' | 'Description' | 'DescriptionDataset' | 'Distribution' | 'DoiCite' | 'FirstRows' | 'Founders' | 'Funder' | 'GatheringProcess' | 'GatheringProcesses' | 'GoldenQuestion' | 'Infrastructure' | 'Keyword' | 'LabelRequeriments' | 'LabelingProcess' | 'LabelingProcesses' | 'Labels' | 'Maintainer' | 'Metadata' | 'Numeri' | 'PairCorrelation' | 'PreProcess' | 'PreProcesses' | 'Provenance' | 'PublishedDate' | 'Publisher' | 'QualityMetric' | 'Quartile' | 'Relation' | 'RelationInstances' | 'ReleaseDate' | 'Requeriments' | 'Sample' | 'SamplingCharacteristics' | 'SocialConcerns' | 'SocialIssue' | 'Source' | 'SpeechSitatuion' | 'Statistics' | 'Tag' | 'Tags' | 'Task' | 'Tasks' | 'Team' | 'Title' | 'UpdateDate' | 'Validation';

export class DatasetDescriptorAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['Applications', 'Area', 'Areas', 'Attribute', 'Author', 'Authoring', 'Authors', 'Benchmarking', 'Binary', 'Categor', 'ChiSquare', 'Citation', 'CiteUrl', 'Citeauthors', 'Composition', 'ConsistencyRules', 'Correlations', 'DataInstance', 'DataInstances', 'Dates', 'Declaration', 'Demographics', 'Dependencies', 'Description', 'DescriptionDataset', 'Distribution', 'DoiCite', 'FirstRows', 'Founders', 'Funder', 'GatheringProcess', 'GatheringProcesses', 'GoldenQuestion', 'Infrastructure', 'Keyword', 'LabelRequeriments', 'LabelingProcess', 'LabelingProcesses', 'Labels', 'Maintainer', 'Metadata', 'Numeri', 'PairCorrelation', 'PreProcess', 'PreProcesses', 'Provenance', 'PublishedDate', 'Publisher', 'QualityMetric', 'Quartile', 'Relation', 'RelationInstances', 'ReleaseDate', 'Requeriments', 'Sample', 'SamplingCharacteristics', 'SocialConcerns', 'SocialIssue', 'Source', 'SpeechSitatuion', 'Statistics', 'Tag', 'Tags', 'Task', 'Tasks', 'Team', 'Title', 'UpdateDate', 'Validation'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Attribute:label': {
                return Labels;
            }
            case 'ConsistencyRules:attr2': {
                return Attribute;
            }
            case 'ConsistencyRules:attrule1': {
                return Attribute;
            }
            case 'ConsistencyRules:instance1': {
                return DataInstance;
            }
            case 'GatheringProcess:labelSocialIssues': {
                return SocialIssue;
            }
            case 'GatheringProcess:mapInstance': {
                return DataInstance;
            }
            case 'LabelingProcess:labelSocialIssues': {
                return SocialIssue;
            }
            case 'Labels:map': {
                return Attribute;
            }
            case 'PairCorrelation:attr1': {
                return Attribute;
            }
            case 'PairCorrelation:attr2': {
                return Attribute;
            }
            case 'PreProcess:labelSocialIssues': {
                return SocialIssue;
            }
            case 'Relation:attRel': {
                return Attribute;
            }
            case 'Relation:attRelTarget': {
                return Attribute;
            }
            case 'Relation:insRel': {
                return DataInstance;
            }
            case 'SocialIssue:senseAtt': {
                return Attribute;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'Applications': {
                return {
                    name: 'Applications',
                    mandatory: [
                        { name: 'future', type: 'array' },
                        { name: 'past', type: 'array' },
                        { name: 'recommend', type: 'array' }
                    ]
                };
            }
            case 'Areas': {
                return {
                    name: 'Areas',
                    mandatory: [
                        { name: 'areas', type: 'array' }
                    ]
                };
            }
            case 'Authoring': {
                return {
                    name: 'Authoring',
                    mandatory: [
                        { name: 'authors', type: 'array' },
                        { name: 'founding', type: 'array' },
                        { name: 'maintainers', type: 'array' }
                    ]
                };
            }
            case 'Authors': {
                return {
                    name: 'Authors',
                    mandatory: [
                        { name: 'authors', type: 'array' }
                    ]
                };
            }
            case 'Categor': {
                return {
                    name: 'Categor',
                    mandatory: [
                        { name: 'catdist', type: 'array' },
                        { name: 'lenghthistorgram', type: 'array' },
                        { name: 'metrics', type: 'array' }
                    ]
                };
            }
            case 'Citation': {
                return {
                    name: 'Citation',
                    mandatory: [
                        { name: 'keywords', type: 'array' }
                    ]
                };
            }
            case 'Composition': {
                return {
                    name: 'Composition',
                    mandatory: [
                        { name: 'compodesc', type: 'array' },
                        { name: 'instances', type: 'array' }
                    ]
                };
            }
            case 'Correlations': {
                return {
                    name: 'Correlations',
                    mandatory: [
                        { name: 'cramers', type: 'array' },
                        { name: 'kendall', type: 'array' },
                        { name: 'pearson', type: 'array' },
                        { name: 'phik', type: 'array' },
                        { name: 'spearman', type: 'array' }
                    ]
                };
            }
            case 'DataInstance': {
                return {
                    name: 'DataInstance',
                    mandatory: [
                        { name: 'attributes', type: 'array' },
                        { name: 'rules', type: 'array' },
                        { name: 'statistics', type: 'array' }
                    ]
                };
            }
            case 'DataInstances': {
                return {
                    name: 'DataInstances',
                    mandatory: [
                        { name: 'instances', type: 'array' }
                    ]
                };
            }
            case 'Description': {
                return {
                    name: 'Description',
                    mandatory: [
                        { name: 'descriptionTasks', type: 'array' }
                    ]
                };
            }
            case 'DescriptionDataset': {
                return {
                    name: 'DescriptionDataset',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'FirstRows': {
                return {
                    name: 'FirstRows',
                    mandatory: [
                        { name: 'rows', type: 'array' }
                    ]
                };
            }
            case 'Founders': {
                return {
                    name: 'Founders',
                    mandatory: [
                        { name: 'funders', type: 'array' }
                    ]
                };
            }
            case 'GatheringProcess': {
                return {
                    name: 'GatheringProcess',
                    mandatory: [
                        { name: 'requeriments', type: 'array' }
                    ]
                };
            }
            case 'GatheringProcesses': {
                return {
                    name: 'GatheringProcesses',
                    mandatory: [
                        { name: 'processes', type: 'array' }
                    ]
                };
            }
            case 'LabelingProcess': {
                return {
                    name: 'LabelingProcess',
                    mandatory: [
                        { name: 'requeriments', type: 'array' }
                    ]
                };
            }
            case 'LabelingProcesses': {
                return {
                    name: 'LabelingProcesses',
                    mandatory: [
                        { name: 'labprocesses', type: 'array' }
                    ]
                };
            }
            case 'LabelRequeriments': {
                return {
                    name: 'LabelRequeriments',
                    mandatory: [
                        { name: 'requeriments', type: 'array' }
                    ]
                };
            }
            case 'Numeri': {
                return {
                    name: 'Numeri',
                    mandatory: [
                        { name: 'metrics', type: 'array' }
                    ]
                };
            }
            case 'PreProcesses': {
                return {
                    name: 'PreProcesses',
                    mandatory: [
                        { name: 'preprocesses', type: 'array' }
                    ]
                };
            }
            case 'Provenance': {
                return {
                    name: 'Provenance',
                    mandatory: [
                        { name: 'gathering', type: 'array' },
                        { name: 'labeling', type: 'array' },
                        { name: 'other', type: 'array' }
                    ]
                };
            }
            case 'RelationInstances': {
                return {
                    name: 'RelationInstances',
                    mandatory: [
                        { name: 'relation', type: 'array' }
                    ]
                };
            }
            case 'Sample': {
                return {
                    name: 'Sample',
                    mandatory: [
                        { name: 'charact', type: 'array' }
                    ]
                };
            }
            case 'SocialConcerns': {
                return {
                    name: 'SocialConcerns',
                    mandatory: [
                        { name: 'socialIssues', type: 'array' }
                    ]
                };
            }
            case 'Source': {
                return {
                    name: 'Source',
                    mandatory: [
                        { name: 'noise', type: 'array' }
                    ]
                };
            }
            case 'Statistics': {
                return {
                    name: 'Statistics',
                    mandatory: [
                        { name: 'metric', type: 'array' },
                        { name: 'pair', type: 'array' }
                    ]
                };
            }
            case 'Tags': {
                return {
                    name: 'Tags',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'Tasks': {
                return {
                    name: 'Tasks',
                    mandatory: [
                        { name: 'descriptionTasks', type: 'array' }
                    ]
                };
            }
            case 'Validation': {
                return {
                    name: 'Validation',
                    mandatory: [
                        { name: 'requeriments', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new DatasetDescriptorAstReflection();
